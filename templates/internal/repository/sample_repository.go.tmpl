package repository

import (
	"context"
	"database/sql"
	"fmt"
	"strings"
	"time"

	"github.com/jmoiron/sqlx"
	"{{.ModuleName}}/internal/dto/request"
	"{{.ModuleName}}/internal/entity"
)

// MySQL{{.SampleAPIName}}Repository implements {{.SampleAPIName}}Repository using MySQL
type MySQL{{.SampleAPIName}}Repository struct {
	db *sqlx.DB
}

// NewMySQL{{.SampleAPIName}}Repository creates a new MySQL {{.SampleAPINameLower}} repository
func NewMySQL{{.SampleAPIName}}Repository(db *sqlx.DB) {{.SampleAPIName}}Repository {
	return &MySQL{{.SampleAPIName}}Repository{
		db: db,
	}
}

// Create inserts a new {{.SampleAPINameLower}} into the database
func (r *MySQL{{.SampleAPIName}}Repository) Create(ctx context.Context, item *entity.{{.SampleAPIName}}) error {
	now := time.Now()
	item.CreatedAt = now
	item.UpdatedAt = now

	query := `
		INSERT INTO {{.SampleTableName}} (name, description, status, created_at, updated_at)
		VALUES (:name, :description, :status, :created_at, :updated_at)
	`

	result, err := r.db.NamedExecContext(ctx, query, item)
	if err != nil {
		return fmt.Errorf("failed to create {{.SampleAPINameLower}}: %w", err)
	}

	id, err := result.LastInsertId()
	if err != nil {
		return fmt.Errorf("failed to get inserted {{.SampleAPINameLower}} ID: %w", err)
	}

	item.ID = id
	return nil
}

// GetByID retrieves a {{.SampleAPINameLower}} by its ID
func (r *MySQL{{.SampleAPIName}}Repository) GetByID(ctx context.Context, id int64) (*entity.{{.SampleAPIName}}, error) {
	var item entity.{{.SampleAPIName}}
	query := `
		SELECT id, name, description, status, created_at, updated_at
		FROM {{.SampleTableName}}
		WHERE id = ?
	`

	err := r.db.GetContext(ctx, &item, query, id)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, fmt.Errorf("{{.SampleAPINameLower}} not found")
		}
		return nil, fmt.Errorf("failed to get {{.SampleAPINameLower}}: %w", err)
	}

	return &item, nil
}

// List retrieves a paginated list of {{.SampleAPINameLower}}s with filtering and sorting
func (r *MySQL{{.SampleAPIName}}Repository) List(ctx context.Context, req request.List{{.SampleAPIName}}sRequest) ([]entity.{{.SampleAPIName}}, int64, error) {
	var items []entity.{{.SampleAPIName}}
	
	// Build WHERE clause
	whereConditions := []string{"1=1"}
	args := make(map[string]interface{})
	
	if req.Name != nil {
		whereConditions = append(whereConditions, "name LIKE :name")
		args["name"] = "%" + *req.Name + "%"
	}
	
	if req.Status != nil {
		whereConditions = append(whereConditions, "status = :status")
		args["status"] = *req.Status
	}
	
	if req.FromDate != nil {
		whereConditions = append(whereConditions, "created_at >= :from_date")
		args["from_date"] = *req.FromDate
	}
	
	if req.ToDate != nil {
		whereConditions = append(whereConditions, "created_at <= :to_date")
		args["to_date"] = *req.ToDate
	}
	
	whereClause := strings.Join(whereConditions, " AND ")
	
	// Get total count
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM {{.SampleTableName}} WHERE %s", whereClause)
	var totalCount int64
	stmt, err := r.db.PrepareNamed(countQuery)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to prepare count query: %w", err)
	}
	defer stmt.Close()
	
	err = stmt.Get(&totalCount, args)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to count {{.SampleAPINameLower}}s: %w", err)
	}
	
	// Build ORDER BY clause
	sortBy := req.SortBy
	if sortBy == "" {
		sortBy = "created_at"
	}
	sortOrder := req.SortOrder
	if sortOrder == "" {
		sortOrder = "desc"
	}
	orderBy := fmt.Sprintf("ORDER BY %s %s", sortBy, strings.ToUpper(sortOrder))
	
	// Build main query with pagination
	args["limit"] = req.GetLimit()
	args["offset"] = req.GetOffset()
	
	query := fmt.Sprintf(`
		SELECT id, name, description, status, created_at, updated_at
		FROM {{.SampleTableName}}
		WHERE %s
		%s
		LIMIT :limit OFFSET :offset
	`, whereClause, orderBy)
	
	stmt, err = r.db.PrepareNamed(query)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to prepare list query: %w", err)
	}
	defer stmt.Close()
	
	err = stmt.Select(&items, args)
	if err != nil {
		return nil, 0, fmt.Errorf("failed to list {{.SampleAPINameLower}}s: %w", err)
	}
	
	return items, totalCount, nil
}

// Count returns the total number of {{.SampleAPINameLower}}s
func (r *MySQL{{.SampleAPIName}}Repository) Count(ctx context.Context) (int64, error) {
	var count int64
	query := "SELECT COUNT(*) FROM {{.SampleTableName}}"
	
	err := r.db.GetContext(ctx, &count, query)
	if err != nil {
		return 0, fmt.Errorf("failed to count {{.SampleAPINameLower}}s: %w", err)
	}
	
	return count, nil
}

// CountByStatus returns the count of {{.SampleAPINameLower}}s by status
func (r *MySQL{{.SampleAPIName}}Repository) CountByStatus(ctx context.Context, status entity.{{.SampleAPIName}}Status) (int64, error) {
	var count int64
	query := "SELECT COUNT(*) FROM {{.SampleTableName}} WHERE status = ?"
	
	err := r.db.GetContext(ctx, &count, query, status)
	if err != nil {
		return 0, fmt.Errorf("failed to count {{.SampleAPINameLower}}s by status: %w", err)
	}
	
	return count, nil
}

// Update updates a {{.SampleAPINameLower}} in the database
func (r *MySQL{{.SampleAPIName}}Repository) Update(ctx context.Context, item *entity.{{.SampleAPIName}}) error {
	item.UpdatedAt = time.Now()
	
	query := `
		UPDATE {{.SampleTableName}}
		SET name = :name, description = :description, status = :status, updated_at = :updated_at
		WHERE id = :id
	`
	
	result, err := r.db.NamedExecContext(ctx, query, item)
	if err != nil {
		return fmt.Errorf("failed to update {{.SampleAPINameLower}}: %w", err)
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	if rowsAffected == 0 {
		return fmt.Errorf("{{.SampleAPINameLower}} not found")
	}
	
	return nil
}

// UpdateStatus updates the status of a {{.SampleAPINameLower}}
func (r *MySQL{{.SampleAPIName}}Repository) UpdateStatus(ctx context.Context, id int64, status entity.{{.SampleAPIName}}Status) error {
	query := `
		UPDATE {{.SampleTableName}}
		SET status = ?, updated_at = ?
		WHERE id = ?
	`
	
	result, err := r.db.ExecContext(ctx, query, status, time.Now(), id)
	if err != nil {
		return fmt.Errorf("failed to update {{.SampleAPINameLower}} status: %w", err)
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	if rowsAffected == 0 {
		return fmt.Errorf("{{.SampleAPINameLower}} not found")
	}
	
	return nil
}

// BulkUpdateStatus updates the status of multiple {{.SampleAPINameLower}}s
func (r *MySQL{{.SampleAPIName}}Repository) BulkUpdateStatus(ctx context.Context, ids []int64, status entity.{{.SampleAPIName}}Status) (int, []int64, error) {
	if len(ids) == 0 {
		return 0, []int64{}, nil
	}
	
	placeholders := make([]string, len(ids))
	args := make([]interface{}, len(ids)+2)
	args[0] = status
	args[1] = time.Now()
	
	for i, id := range ids {
		placeholders[i] = "?"
		args[i+2] = id
	}
	
	query := fmt.Sprintf(`
		UPDATE {{.SampleTableName}}
		SET status = ?, updated_at = ?
		WHERE id IN (%s)
	`, strings.Join(placeholders, ","))
	
	result, err := r.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, ids, fmt.Errorf("failed to bulk update {{.SampleAPINameLower}} status: %w", err)
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return 0, ids, fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	updatedCount := int(rowsAffected)
	failedIDs := []int64{}
	
	// Identify which IDs failed (simple approach: if not all succeeded, check each)
	if updatedCount < len(ids) {
		for _, id := range ids {
			exists, err := r.ExistsByID(ctx, id)
			if err != nil || !exists {
				failedIDs = append(failedIDs, id)
			}
		}
	}
	
	return updatedCount, failedIDs, nil
}

// Delete removes a {{.SampleAPINameLower}} from the database
func (r *MySQL{{.SampleAPIName}}Repository) Delete(ctx context.Context, id int64) error {
	query := "DELETE FROM {{.SampleTableName}} WHERE id = ?"
	
	result, err := r.db.ExecContext(ctx, query, id)
	if err != nil {
		return fmt.Errorf("failed to delete {{.SampleAPINameLower}}: %w", err)
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return fmt.Errorf("failed to get rows affected: %w", err)
	}
	
	if rowsAffected == 0 {
		return fmt.Errorf("{{.SampleAPINameLower}} not found")
	}
	
	return nil
}

// ExistsByID checks if a {{.SampleAPINameLower}} exists by its ID
func (r *MySQL{{.SampleAPIName}}Repository) ExistsByID(ctx context.Context, id int64) (bool, error) {
	var count int64
	query := "SELECT COUNT(*) FROM {{.SampleTableName}} WHERE id = ?"
	
	err := r.db.GetContext(ctx, &count, query, id)
	if err != nil {
		return false, fmt.Errorf("failed to check {{.SampleAPINameLower}} existence: %w", err)
	}
	
	return count > 0, nil
}
