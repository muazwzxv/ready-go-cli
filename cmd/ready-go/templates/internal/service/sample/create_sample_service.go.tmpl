package service

import (
	"context"
	"errors"

	"github.com/gofiber/fiber/v2"
	"github.com/samber/do/v2"
	"{{.ModuleName}}/internal/dto/request"
	"{{.ModuleName}}/internal/dto/response"
	"{{.ModuleName}}/internal/entity"
	"{{.ModuleName}}/internal/repository"
)

type {{.SampleAPIName}}ServiceImpl struct {
	repo repository.{{.SampleAPIName}}Repository
}

func New{{.SampleAPIName}}Service(i do.Injector) ({{.SampleAPIName}}Service, error) {
	repo := do.MustInvoke[repository.{{.SampleAPIName}}Repository](i)

	return &{{.SampleAPIName}}ServiceImpl{
		repo: repo,
	}, nil
}

func (s *{{.SampleAPIName}}ServiceImpl) Create{{.SampleAPIName}}(ctx context.Context, req request.Create{{.SampleAPIName}}Request) (*response.{{.SampleAPIName}}Response, error) {
	status := entity.{{.SampleAPIName}}StatusActive
	if req.Status != "" {
		status = entity.{{.SampleAPIName}}Status(req.Status)
	}

	item := &entity.{{.SampleAPIName}}{
		Name:        req.Name,
		Description: req.Description,
		Status:      status,
	}

	if err := s.repo.Create(ctx, item); err != nil {
		if errors.Is(err, repository.ErrNotFound) {
			return nil, response.BuildErrorWithCode(
				fiber.StatusNotFound,
				"{{.SampleAPIName}} not found",
				"PRODUCT_NOT_FOUND",
			)
		}
		return nil, response.BuildErrorWithCode(
			fiber.StatusInternalServerError,
			"Database operation failed",
			"DB_ERROR",
		)
	}

	return s.entityToResponse(item), nil
}

func (s *{{.SampleAPIName}}ServiceImpl) entityToResponse(item *entity.{{.SampleAPIName}}) *response.{{.SampleAPIName}}Response {
	return &response.{{.SampleAPIName}}Response{
		ID:          item.ID,
		Name:        item.Name,
		Description: item.Description,
		Status:      item.Status,
		CreatedAt:   item.CreatedAt,
		UpdatedAt:   item.UpdatedAt,
		IsActive:    item.IsActive(),
	}
}
