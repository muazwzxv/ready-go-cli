package repository

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"strings"

	"{{.ModuleName}}/internal/database/store"
	"{{.ModuleName}}/internal/dto/request"
	"{{.ModuleName}}/internal/entity"
)

type MySQL{{.SampleAPIName}}Repository struct {
	queries *store.Queries
	db      store.DBTX
}

func NewMySQL{{.SampleAPIName}}Repository(queries *store.Queries, db store.DBTX) {{.SampleAPIName}}Repository {
	return &MySQL{{.SampleAPIName}}Repository{
		queries: queries,
		db:      db,
	}
}

func (r *MySQL{{.SampleAPIName}}Repository) Create(ctx context.Context, item *entity.{{.SampleAPIName}}) error {
	result, err := r.queries.Create{{.SampleAPIName}}(ctx, r.db, store.Create{{.SampleAPIName}}Params{
		Name: item.Name,
		Description: sql.NullString{
			String: item.Description,
			Valid:  item.Description != "",
		},
		Status: string(item.Status),
	})
	if err != nil {
		return ErrDatabaseError
	}

	id, err := result.LastInsertId()
	if err != nil {
		return ErrDatabaseError
	}

	item.ID = id
	return nil
}

func (r *MySQL{{.SampleAPIName}}Repository) GetByID(ctx context.Context, id int64) (*entity.{{.SampleAPIName}}, error) {
	row, err := r.queries.Get{{.SampleAPIName}}ByID(ctx, r.db, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, ErrNotFound
		}
		return nil, ErrDatabaseError
	}

	return r.toEntity(row), nil
}

func (r *MySQL{{.SampleAPIName}}Repository) List(ctx context.Context, req request.List{{.SampleAPIName}}sRequest) ([]entity.{{.SampleAPIName}}, int64, error) {
	whereConditions := []string{"1=1"}
	args := make([]interface{}, 0)
	
	if req.Name != nil {
		whereConditions = append(whereConditions, "name LIKE ?")
		args = append(args, "%"+*req.Name+"%")
	}
	
	if req.Status != nil {
		whereConditions = append(whereConditions, "status = ?")
		args = append(args, *req.Status)
	}
	
	if req.FromDate != nil {
		whereConditions = append(whereConditions, "created_at >= ?")
		args = append(args, *req.FromDate)
	}
	
	if req.ToDate != nil {
		whereConditions = append(whereConditions, "created_at <= ?")
		args = append(args, *req.ToDate)
	}
	
	whereClause := strings.Join(whereConditions, " AND ")
	
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM {{.SampleTableName}} WHERE %s", whereClause)
	var totalCount int64
	
	row := r.db.QueryRowContext(ctx, countQuery, args...)
	if err := row.Scan(&totalCount); err != nil {
		return nil, 0, ErrDatabaseError
	}
	
	sortBy := req.SortBy
	if sortBy == "" {
		sortBy = "created_at"
	}
	sortOrder := req.SortOrder
	if sortOrder == "" {
		sortOrder = "desc"
	}
	orderBy := fmt.Sprintf("ORDER BY %s %s", sortBy, strings.ToUpper(sortOrder))
	
	queryArgs := append(args, req.GetLimit(), req.GetOffset())
	query := fmt.Sprintf(`
		SELECT id, name, description, status, created_at, updated_at
		FROM {{.SampleTableName}}
		WHERE %s
		%s
		LIMIT ? OFFSET ?
	`, whereClause, orderBy)
	
	rows, err := r.db.QueryContext(ctx, query, queryArgs...)
	if err != nil {
		return nil, 0, ErrDatabaseError
	}
	defer rows.Close()
	
	var items []entity.{{.SampleAPIName}}
	for rows.Next() {
		var item entity.{{.SampleAPIName}}
		var description sql.NullString
		var createdAt, updatedAt sql.NullTime
		
		err := rows.Scan(
			&item.ID,
			&item.Name,
			&description,
			&item.Status,
			&createdAt,
			&updatedAt,
		)
		if err != nil {
			return nil, 0, ErrDatabaseError
		}
		
		if description.Valid {
			item.Description = description.String
		}
		if createdAt.Valid {
			item.CreatedAt = createdAt.Time
		}
		if updatedAt.Valid {
			item.UpdatedAt = updatedAt.Time
		}
		
		items = append(items, item)
	}
	
	if err := rows.Err(); err != nil {
		return nil, 0, ErrDatabaseError
	}
	
	return items, totalCount, nil
}

func (r *MySQL{{.SampleAPIName}}Repository) Count(ctx context.Context) (int64, error) {
	count, err := r.queries.Count{{.SampleAPIName}}s(ctx, r.db)
	if err != nil {
		return 0, ErrDatabaseError
	}
	return count, nil
}

func (r *MySQL{{.SampleAPIName}}Repository) CountByStatus(ctx context.Context, status entity.{{.SampleAPIName}}Status) (int64, error) {
	rows, err := r.queries.Get{{.SampleAPIName}}sByStatus(ctx, r.db, string(status))
	if err != nil {
		return 0, ErrDatabaseError
	}
	return int64(len(rows)), nil
}

func (r *MySQL{{.SampleAPIName}}Repository) Update(ctx context.Context, item *entity.{{.SampleAPIName}}) error {
	err := r.queries.Update{{.SampleAPIName}}(ctx, r.db, store.Update{{.SampleAPIName}}Params{
		Name: item.Name,
		Description: sql.NullString{
			String: item.Description,
			Valid:  item.Description != "",
		},
		Status: string(item.Status),
		ID:     item.ID,
	})
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return ErrNotFound
		}
		return ErrDatabaseError
	}
	return nil
}

func (r *MySQL{{.SampleAPIName}}Repository) UpdateStatus(ctx context.Context, id int64, status entity.{{.SampleAPIName}}Status) error {
	query := "UPDATE {{.SampleTableName}} SET status = ?, updated_at = NOW() WHERE id = ?"
	result, err := r.db.ExecContext(ctx, query, string(status), id)
	if err != nil {
		return ErrDatabaseError
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return ErrDatabaseError
	}
	
	if rowsAffected == 0 {
		return ErrNotFound
	}
	
	return nil
}

func (r *MySQL{{.SampleAPIName}}Repository) BulkUpdateStatus(ctx context.Context, ids []int64, status entity.{{.SampleAPIName}}Status) (int, []int64, error) {
	if len(ids) == 0 {
		return 0, []int64{}, nil
	}
	
	placeholders := make([]string, len(ids))
	args := make([]interface{}, len(ids)+1)
	args[0] = string(status)
	
	for i, id := range ids {
		placeholders[i] = "?"
		args[i+1] = id
	}
	
	query := fmt.Sprintf(`
		UPDATE {{.SampleTableName}}
		SET status = ?, updated_at = NOW()
		WHERE id IN (%s)
	`, strings.Join(placeholders, ","))
	
	result, err := r.db.ExecContext(ctx, query, args...)
	if err != nil {
		return 0, ids, ErrDatabaseError
	}
	
	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return 0, ids, ErrDatabaseError
	}
	
	updatedCount := int(rowsAffected)
	failedIDs := []int64{}
	
	if updatedCount < len(ids) {
		for _, id := range ids {
			exists, err := r.ExistsByID(ctx, id)
			if err != nil || !exists {
				failedIDs = append(failedIDs, id)
			}
		}
	}
	
	return updatedCount, failedIDs, nil
}

func (r *MySQL{{.SampleAPIName}}Repository) Delete(ctx context.Context, id int64) error {
	err := r.queries.Delete{{.SampleAPIName}}(ctx, r.db, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return ErrNotFound
		}
		return ErrDatabaseError
	}
	return nil
}

func (r *MySQL{{.SampleAPIName}}Repository) ExistsByID(ctx context.Context, id int64) (bool, error) {
	_, err := r.queries.Get{{.SampleAPIName}}ByID(ctx, r.db, id)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return false, nil
		}
		return false, ErrDatabaseError
	}
	return true, nil
}

func (r *MySQL{{.SampleAPIName}}Repository) toEntity(row *store.{{.SampleAPIName}}) *entity.{{.SampleAPIName}} {
	result := &entity.{{.SampleAPIName}}{
		ID:     row.ID,
		Name:   row.Name,
		Status: entity.{{.SampleAPIName}}Status(row.Status),
	}
	
	if row.Description.Valid {
		result.Description = row.Description.String
	}
	if row.CreatedAt.Valid {
		result.CreatedAt = row.CreatedAt.Time
	}
	if row.UpdatedAt.Valid {
		result.UpdatedAt = row.UpdatedAt.Time
	}
	
	return result
}
