package repository

import (
	"context"
	"database/sql"

	"github.com/samber/do/v2"
	"{{.ModuleName}}/internal/database"
	"{{.ModuleName}}/internal/database/store"
	"{{.ModuleName}}/internal/entity"
)

type {{.SampleAPIName}}RepositoryImpl struct {
	queries *store.Queries
	db      store.DBTX
}

func New{{.SampleAPIName}}Repository(i do.Injector) ({{.SampleAPIName}}Repository, error) {
	queries := do.MustInvoke[*store.Queries](i)
	db := do.MustInvoke[*database.Database](i)

	return &{{.SampleAPIName}}RepositoryImpl{
		queries: queries,
		db:      db.DB, // Extract *sqlx.DB from Database wrapper
	}, nil
}

func (r *{{.SampleAPIName}}RepositoryImpl) Create(ctx context.Context, item *entity.{{.SampleAPIName}}) error {
	result, err := r.queries.Create{{.SampleAPIName}}(ctx, r.db, store.Create{{.SampleAPIName}}Params{
		Name: item.Name,
		Description: sql.NullString{
			String: item.Description,
			Valid:  item.Description != "",
		},
		Status: string(item.Status),
	})
	if err != nil {
		return err
	}

	id, err := result.LastInsertId()
	if err != nil {
		return err
	}

	item.ID = id
	return nil
}

func (r *{{.SampleAPIName}}RepositoryImpl) GetByID(ctx context.Context, id int64) (*entity.{{.SampleAPIName}}, error) {
	row, err := r.queries.Get{{.SampleAPIName}}ByID(ctx, r.db, id)
	if err != nil {
		return nil, err
	}

	return r.toEntity(row), nil
}

func (r *{{.SampleAPIName}}RepositoryImpl) toEntity(row *store.{{.SampleAPIName}}) *entity.{{.SampleAPIName}} {
	result := &entity.{{.SampleAPIName}}{
		ID:     row.ID,
		Name:   row.Name,
		Status: entity.{{.SampleAPIName}}Status(row.Status),
	}
	
	if row.Description.Valid {
		result.Description = row.Description.String
	}
	if row.CreatedAt.Valid {
		result.CreatedAt = row.CreatedAt.Time
	}
	if row.UpdatedAt.Valid {
		result.UpdatedAt = row.UpdatedAt.Time
	}
	
	return result
}
